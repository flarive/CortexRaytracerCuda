  Compiling CUDA source file main.cu...
  
  E:\MyProjects\MyOwnRaytracerCuda2\core>"E:\Cuda\bin\nvcc.exe" -gencode=arch=compute_52,code=\"sm_52,compute_52\" --use-local-env -ccbin "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.40.33807\bin\HostX64\x64" -x cu   -IE:\MyProjects\MyOwnRaytracerCuda2\libs -IE:\MyProjects\MyOwnRaytracerCuda2\libs -IE:\Cuda\include -IE:\Cuda\include  -G   --keep-dir x64\Debug  -maxrregcount=0   --machine 64 --compile -cudart static  -g  -DWIN32 -DWIN64 -D_DEBUG -D_CONSOLE -D_MBCS -Xcompiler "/EHsc /W3 /nologo /Od /FS /Zi /RTC1 /MDd " -Xcompiler "/Fdx64\Debug\vc143.pdb" -o E:\MyProjects\MyOwnRaytracerCuda2\core\x64\Debug\main.cu.obj "E:\MyProjects\MyOwnRaytracerCuda2\core\main.cu" 
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec2.hpp(97): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
  Remark: The warnings can be suppressed with "-diag-suppress <warning-number>"
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec2.hpp(97): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec3.hpp(102): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec3.hpp(102): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec4.hpp(100): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec4.hpp(100): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x2.hpp(35): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x2.hpp(35): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x3.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x3.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x4.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x4.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x2.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x2.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x3.hpp(35): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x3.hpp(35): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x4.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x4.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x2.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x2.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x3.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x3.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x4.hpp(35): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x4.hpp(35): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\detail/type_vec1.hpp(95): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\detail/type_vec1.hpp(95): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_quat.hpp(73): warning #20012-D: __device__ annotation is ignored on a function("qua") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  qua() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_quat.hpp(73): warning #20012-D: __host__ annotation is ignored on a function("qua") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  qua() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec2.hpp(97): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
  Remark: The warnings can be suppressed with "-diag-suppress <warning-number>"
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec2.hpp(97): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec3.hpp(102): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec3.hpp(102): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec4.hpp(100): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_vec4.hpp(100): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x2.hpp(35): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x2.hpp(35): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x3.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x3.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x4.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat2x4.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x2.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x2.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x3.hpp(35): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x3.hpp(35): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x4.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat3x4.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x2.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x2.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x3.hpp(36): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x3.hpp(36): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x4.hpp(35): warning #20012-D: __device__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_mat4x4.hpp(35): warning #20012-D: __host__ annotation is ignored on a function("mat") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  mat() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\detail/type_vec1.hpp(95): warning #20012-D: __device__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\detail/type_vec1.hpp(95): warning #20012-D: __host__ annotation is ignored on a function("vec") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  vec() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_quat.hpp(73): warning #20012-D: __device__ annotation is ignored on a function("qua") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  qua() = default;
    		           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\glm\ext\../detail/type_quat.hpp(73): warning #20012-D: __host__ annotation is ignored on a function("qua") that is explicitly defaulted on its first declaration
    		__declspec(__device__) __declspec(__host__)  qua() = default;
    		                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/util/Memory.h(189): warning #20013-D: calling a constexpr __host__ function("min") from a __host__ __device__ function("handmade_aligned_realloc") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
        std::size_t count = (std::min)(new_size, old_size);
                            ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/util/Memory.h(189): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
        std::size_t count = (std::min)(new_size, old_size);
                          ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1334): warning #20013-D: calling a constexpr __host__ function("real") from a __host__ __device__ function("abs") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypotf(x.real(), x.imag());
                        ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1334): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("abs") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypotf(x.real(), x.imag());
                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1334): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypotf(x.real(), x.imag());
      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1334): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypotf(x.real(), x.imag());
      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1339): warning #20013-D: calling a constexpr __host__ function("real") from a __host__ __device__ function("abs") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypot(x.real(), x.imag());
                       ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1339): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("abs") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypot(x.real(), x.imag());
                                 ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1339): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypot(x.real(), x.imag());
      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1339): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return ::hypot(x.real(), x.imag());
      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1414): warning #20013-D: calling a constexpr __host__ function("real") from a __host__ __device__ function("exp") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      float com = ::expf(x.real());
                           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1415): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("exp") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      float res_real = com * ::cosf(x.imag());
                                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1416): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("exp") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      float res_imag = com * ::sinf(x.imag());
                                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1414): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      float com = ::expf(x.real());
                ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1415): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      float res_real = com * ::cosf(x.imag());
                     ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1416): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      float res_imag = com * ::sinf(x.imag());
                     ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1417): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return std::complex<float>(res_real, res_imag);
      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1422): warning #20013-D: calling a constexpr __host__ function("real") from a __host__ __device__ function("exp") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      double com = ::exp(x.real());
                           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1423): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("exp") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      double res_real = com * ::cos(x.imag());
                                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1424): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("exp") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      double res_imag = com * ::sin(x.imag());
                                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1422): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      double com = ::exp(x.real());
                 ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1423): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      double res_real = com * ::cos(x.imag());
                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1424): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      double res_imag = com * ::sin(x.imag());
                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(1425): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return std::complex<double>(res_real, res_imag);
      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/RandomImpl.h(144): warning #20208-D: 'long double' is treated as 'double' in device code
        return static_cast<long double>(random_float_impl<double>::run(numRandomBits));
                           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                  ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(221): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a) { return std::complex<float>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator+(const float& a, const std::complex<float>& b) { return std::complex<float>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const std::complex<float>& b) { return std::complex<float>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator-(const float& a, const std::complex<float>& b) { return std::complex<float>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const std::complex<float>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator*(const float& a, const std::complex<float>& b) { return std::complex<float>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const std::complex<float>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const std::complex<float>& a, const float& b) { return std::complex<float>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<float> operator/(const float& a, const std::complex<float>& b) { return complex_divide(std::complex<float>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator+=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator-=(std::complex<float>& a, const std::complex<float>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator*=(std::complex<float>& a, const std::complex<float>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<float>& operator/=(std::complex<float>& a, const std::complex<float>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const std::complex<float>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<float>& a, const float& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const float& a, const std::complex<float>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const std::complex<float>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<float>& a, const float& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const float& a, const std::complex<float>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(222): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
    __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a) { return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a) { return std::complex<double>(-numext::real(a), -numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) + numext::real(b), numext::imag(a) + numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) + b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator+(const double& a, const std::complex<double>& b) { return std::complex<double>(a + numext::real(b), numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const std::complex<double>& b) { return std::complex<double>(numext::real(a) - numext::real(b), numext::imag(a) - numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) - b, numext::imag(a)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator-(const double& a, const std::complex<double>& b) { return std::complex<double>(a - numext::real(b), -numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const std::complex<double>& b) { return complex_multiply(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) * b, numext::imag(a) * b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator*(const double& a, const std::complex<double>& b) { return std::complex<double>(a * numext::real(b), a * numext::imag(b)); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const std::complex<double>& b) { return complex_divide(a, b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const std::complex<double>& a, const double& b) { return std::complex<double>(numext::real(a) / b, numext::imag(a) / b); } __declspec(__host__) __declspec(__device__) inline std::complex<double> operator/(const double& a, const std::complex<double>& b) { return complex_divide(std::complex<double>(a, 0), b); } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator+=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) += numext::real(b); numext::imag_ref(a) += numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator-=(std::complex<double>& a, const std::complex<double>& b) { numext::real_ref(a) -= numext::real(b); numext::imag_ref(a) -= numext::imag(b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator*=(std::complex<double>& a, const std::complex<double>& b) { a = complex_multiply(a, b); return a; } __declspec(__host__) __declspec(__device__) inline std::complex<double>& operator/=(std::complex<double>& a, const std::complex<double>& b) { a = complex_divide(a, b); return a; } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const std::complex<double>& b) { return numext::real(a) == numext::real(b) && numext::imag(a) == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator==(const std::complex<double>& a, const double& b) { return numext::real(a) == b && numext::imag(a) == 0; } __declspec(__host__) __declspec(__device__) inline bool operator==(const double& a, const std::complex<double>& b) { return a == numext::real(b) && 0 == numext::imag(b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const std::complex<double>& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const std::complex<double>& a, const double& b) { return !(a == b); } __declspec(__host__) __declspec(__device__) inline bool operator!=(const double& a, const std::complex<double>& b) { return !(a == b); }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\stb/stb_image.h(4275): warning #550-D: variable "old_limit" was set but never used
       unsigned int cur, limit, old_limit;
                                ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\stb/stb_image.h(5182): warning #550-D: variable "idata_limit_old" was set but never used
                   stbi__uint32 idata_limit_old = idata_limit;
                                ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\stb/stb_image.h(6969): warning #550-D: variable "out_size" was set but never used
          int out_size = 0;
              ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\stb/stb_image.h(6970): warning #550-D: variable "delays_size" was set but never used
          int delays_size = 0;
              ^
  
E:\MyProjects\MyOwnRaytracerCuda2\core\main.cu(102): warning #177-D: variable "local_rand_state" was declared but never referenced
            curandState local_rand_state = *rand_state;
                        ^
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(96): warning #20013-D: calling a constexpr __host__ function("real") from a __host__ __device__ function("run") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.real(); }
                                                                                                           ^
            detected during:
              instantiation of "T Eigen::internal::real_impl<std::complex<T>>::run(const std::complex<T> &) [with T=float]" at line 1024
              instantiation of "Eigen::internal::real_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::real(const Scalar &) [with Scalar=std::complex<float>]" at line 221 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(96): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.real(); }
                                                                                                  ^
            detected during:
              instantiation of "T Eigen::internal::real_impl<std::complex<T>>::run(const std::complex<T> &) [with T=float]" at line 1024
              instantiation of "Eigen::internal::real_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::real(const Scalar &) [with Scalar=std::complex<float>]" at line 221 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(131): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("run") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.imag(); }
                                                                                                           ^
            detected during:
              instantiation of "T Eigen::internal::imag_impl<std::complex<T>>::run(const std::complex<T> &) [with T=float]" at line 1040
              instantiation of "Eigen::internal::imag_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::imag(const Scalar &) [with Scalar=std::complex<float>]" at line 221 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(131): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.imag(); }
                                                                                                  ^
            detected during:
              instantiation of "T Eigen::internal::imag_impl<std::complex<T>>::run(const std::complex<T> &) [with T=float]" at line 1040
              instantiation of "Eigen::internal::imag_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::imag(const Scalar &) [with Scalar=std::complex<float>]" at line 221 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(72): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return std::complex<T>(a_real * b_real - a_imag * b_imag, a_imag * b_real + a_real * b_imag);
      ^
            detected during instantiation of "std::complex<T> Eigen::complex_operator_detail::complex_multiply(const std::complex<T> &, const std::complex<T> &) [with T=float]" at line 221
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(83): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return std::complex<T>((a_real * b_real + a_imag * b_imag) / norm, (a_imag * b_real - a_real * b_imag) / norm);
      ^
            detected during:
              instantiation of "std::complex<T> Eigen::complex_operator_detail::complex_divide_fast(const std::complex<T> &, const std::complex<T> &) [with T=float]" at line 107
              instantiation of "std::complex<T> Eigen::complex_operator_detail::complex_divide(const std::complex<T> &, const std::complex<T> &) [with T=float]" at line 221
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(96): warning #20013-D: calling a constexpr __host__ function("real") from a __host__ __device__ function("run") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.real(); }
                                                                                                           ^
            detected during:
              instantiation of "T Eigen::internal::real_impl<std::complex<T>>::run(const std::complex<T> &) [with T=double]" at line 1024
              instantiation of "Eigen::internal::real_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::real(const Scalar &) [with Scalar=std::complex<double>]" at line 222 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(96): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.real(); }
                                                                                                  ^
            detected during:
              instantiation of "T Eigen::internal::real_impl<std::complex<T>>::run(const std::complex<T> &) [with T=double]" at line 1024
              instantiation of "Eigen::internal::real_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::real(const Scalar &) [with Scalar=std::complex<double>]" at line 222 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(131): warning #20013-D: calling a constexpr __host__ function("imag") from a __host__ __device__ function("run") is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.imag(); }
                                                                                                           ^
            detected during:
              instantiation of "T Eigen::internal::imag_impl<std::complex<T>>::run(const std::complex<T> &) [with T=double]" at line 1040
              instantiation of "Eigen::internal::imag_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::imag(const Scalar &) [with Scalar=std::complex<double>]" at line 222 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/MathFunctions.h(131): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      __declspec(__host__) __declspec(__device__) static inline T run(const std::complex<T>& x) { return x.imag(); }
                                                                                                  ^
            detected during:
              instantiation of "T Eigen::internal::imag_impl<std::complex<T>>::run(const std::complex<T> &) [with T=double]" at line 1040
              instantiation of "Eigen::internal::imag_retval<Eigen::internal::global_math_functions_filtering_base<Scalar, void>::type>::type Eigen::numext::imag(const Scalar &) [with Scalar=std::complex<double>]" at line 222 of E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(72): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return std::complex<T>(a_real * b_real - a_imag * b_imag, a_imag * b_real + a_real * b_imag);
      ^
            detected during instantiation of "std::complex<T> Eigen::complex_operator_detail::complex_multiply(const std::complex<T> &, const std::complex<T> &) [with T=double]" at line 222
  
E:\MyProjects\MyOwnRaytracerCuda2\libs\Eigen\Eigen\src/Core/arch/GPU/Complex.h(83): warning #20015-D: calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
      return std::complex<T>((a_real * b_real + a_imag * b_imag) / norm, (a_imag * b_real - a_real * b_imag) / norm);
      ^
            detected during:
              instantiation of "std::complex<T> Eigen::complex_operator_detail::complex_divide_fast(const std::complex<T> &, const std::complex<T> &) [with T=double]" at line 107
              instantiation of "std::complex<T> Eigen::complex_operator_detail::complex_divide(const std::complex<T> &, const std::complex<T> &) [with T=double]" at line 222
  
CUDACOMPILE : ptxas warning : Stack size for entry function '_Z6renderPN3glm3vecILi3EfLNS_9qualifierE0EEEiiiPP6CameraPP6EntityP17curandStateXORWOW' cannot be statically determined
  main.cu
  tmpxft_000009f8_00000000-7_main.cudafe1.cpp
E:\MyProjects\MyOwnRaytracerCuda2\core\main.cu(286): warning C4244: '=' : conversion de 'double' en 'uint8_t', perte possible de données
E:\MyProjects\MyOwnRaytracerCuda2\core\main.cu(287): warning C4244: '=' : conversion de 'double' en 'uint8_t', perte possible de données
E:\MyProjects\MyOwnRaytracerCuda2\core\main.cu(288): warning C4244: '=' : conversion de 'double' en 'uint8_t', perte possible de données
     Création de la bibliothèque E:\MyProjects\MyOwnRaytracerCuda2\x64\Debug\RTCudaBelval2.lib et de l'objet E:\MyProjects\MyOwnRaytracerCuda2\x64\Debug\RTCudaBelval2.exp
LINK : warning LNK4098: conflit entre la bibliothèque par défaut 'LIBCMT' et les autres bibliothèques ; utilisez /NODEFAULTLIB:library
  RTCudaBelval.vcxproj -> E:\MyProjects\MyOwnRaytracerCuda2\x64\Debug\RTCudaBelval2.exe
